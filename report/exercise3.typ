Σε αυτήν την άσκηση βάζουμε νήματα να ανανεώνουν, πλέον, όχι την ίδια κοινόχρηστη μεταβλητή, αλλά το καθένα την δική του, η οποία βρίσκεται σε ένα κοινόχρηστο πίνακα (το μέγεθος του οποίου είναι ίσο με το πλήθος των νημάτων). Το ποια θέση του πίνακα θα ενημερώνει κάθε νήμα καθορίζεται από το ID του νήματος. Εδώ, δοκιμάζουμε τόσο την χρήση συγχρονισμού (είτε με mutex είτε με atomic) όσο και την απουσία του. Όπως και στην προηγούμενη άσκηση, ελέγχουμε την ορθότητα του προγράμματος με την εντολή `assert`, η οποία ελέγχει ότι η τιμή κάθε θέσης στον πίνακα είναι ίση με το πλήθος των επαναλήψεων. 

Ο πηγαίος κώδικας της άσκησης βρίσκεται στο αρχείο `src/false_sharing.c`.

Η άσκηση δέχεται ακριβώς τα ίδια ορίσματα με την προηγούμενη, με την προσθήκη ενός επιπλέον, του `-fns` για την απουσία συγχρονισμού. Η έξοδος είναι παρόμοια με την προηγούμενη άσκηση, με την διαφορά ότι εδώ έχουμε και την επιλογή να μην χρησιμοποιήσουμε καθόλου συγχρονισμό. Στην περίπτωση όμως που η απουσία του συγχρονισμού δεν περάσει την `assert`, το πρόγραμμα εξάγει αρχείο με σφάλμα, με την σήμανση `SYNCHRONIZATION IS NECESSARY`.

Κατά την εκτέλεση της άσκησης, η υλοποίηση χωρίς συγχρονισμό δεν πέρασε τον έλεγχο. Αυτό σημαίνει ότι παρά το γεγονός ότι κάθε νήμα ενημερώνει την δική του θέση στον πίνακα, ο πίνακας αυτός επειδή αποθηκεύεται στην κρυφή μνήμη του κάθε πυρήνα, δεν είναι απαραίτητο ότι κάθε νήμα θα διαβάσει την σωστή τιμή (το λεγόμενο false sharing).

Οι άλλες δύο υλοποιήσεις εκτελέσθηκαν επιτυχώς και οι επιδόσεις τους είναι οι εξής:

#image("res/img/plot3_locks.png", width: 100%, height: 22%)
#image("res/img/plot3_atomic.png", width: 100%, height: 22%)