Σε αυτήν την άσκηση βάζουμε νήματα να ανανεώνουν, πλέον, όχι την ίδια κοινόχρηστη μεταβλητή, αλλά το καθένα την δική του, η οποία βρίσκεται σε ένα κοινόχρηστο πίνακα (το μέγεθος του οποίου είναι ίσο με το πλήθος των νημάτων). Το ποια θέση του πίνακα θα ενημερώνει κάθε νήμα καθορίζεται από το ID του νήματος. Εδώ, δοκιμάζουμε τόσο την χρήση συγχρονισμού (είτε με mutex είτε με atomic) όσο και την απουσία του. Όπως και στην προηγούμενη άσκηση, ελέγχουμε την ορθότητα του προγράμματος με την εντολή `assert`, η οποία ελέγχει ότι η τιμή κάθε θέσης στον πίνακα είναι ίση με το πλήθος των επαναλήψεων. 

Ο πηγαίος κώδικας της άσκησης βρίσκεται στο αρχείο `src/false_sharing.c`.

Η άσκηση δέχεται ακριβώς τα ίδια ορίσματα με την προηγούμενη, με την προσθήκη ενός επιπλέον, του `-fns` για την απουσία συγχρονισμού. Η έξοδος είναι παρόμοια με την προηγούμενη άσκηση, με την διαφορά ότι εδώ έχουμε και την επιλογή να μην χρησιμοποιήσουμε καθόλου συγχρονισμό. Στην περίπτωση όμως που η απουσία του συγχρονισμού δεν περάσει την `assert`, το πρόγραμμα εξάγει αρχείο με σφάλμα, όπου καταγράφονται οι παράμετροι οι οποίες χρησιμοποιήθηκαν στην αποτυχημένη προσπάθεια.

Κατά την εκτέλεση της άσκησης, οι υλοποιήσεις με κλειδώματα και χωρίς συγχρονισμό απέτυχαν τον έλεγχο για νήματα περισσότερα από 4 (αριθμός μάλιστα ίσος με τον αριθμό των πυρήνων του επεξεργαστή μας).

Οι συλλεχθείσες μετρήσεις για την υλοποίηση με κλειδώματα είναι οι εξής:

#image("res/img/plot3_nosync.png", width: 100%, height: 22%)
#image("res/img/plot3_locks.png", width: 100%, height: 22%)
#image("res/img/plot3_atomic.png", width: 100%, height: 22%)

Προφανώς, η υλοποίηση χωρίς συγχρονισμό είναι η ταχύτερη, αφού δεν έχουμε overhead από χρήση μεθόδων συγχρονισμού.

Μια ενδιαφέρουσα παρατήρηση είναι ότι η υλοποίσηση με atomics σταθεροποιείται από άποψη χρόνου, όταν το πλήθος των νημάτων αρχίζει να αυξάνει κατά πολύ. 