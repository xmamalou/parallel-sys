Σε αυτήν την άσκηση εφαρμόζουμε αλγόριθμο βασισμένο στην μέθοδο Monte Carlo για την εκτίμηση του π. 

Για να το πετύχουμε αυτό, παράγουμε τυχαία σημεία εντός ενός τετραγώνου πλευράς $1$.

Για όσα σημεία $q = (x, y)$ ισχύει ότι $x^2 + y^2 <= 1$, τα σημεία αυτά βρίσκονται εντός του κύκλου ακτίνας $1$. Τότε, αν $A$ είναι το πλήθος όλων των ρίψεων και $B$ το πλήθος των ρίψεων που βρίσκονται εντός του κύκλου, τότε η εκτίμηση του π είναι:

$ pi approx 4B/A $

Ο πηγαίος κώδικας της άσκησης βρίσκεται στο αρχείο `src/pi_calc.c`.

Η άσκηση δέχεται ως ορίσματα το πλήθος των συνολικών ρίψεων (`-fn=<number>`), ποια υλοποίηση θα εκτελεστεί (`-fs` για την σειριακή, `-fp` για την παράλληλη που χρησιμοποιεί pthreads και `-fomp` για την παράλληλη που χρησιμοποιεί openmp) και το πλήθος των νημάτων που θα χρησιμοποιηθούν (`-fj=<number>`). Η έξοδος είναι το εκτιμώμενο π και ο χρόνος εκτέλεσης του αλγορίθμου, όπως και η υλοποίηση που χρησιμοποιήθηκε αλλά και το πλήθος των ρίψεων, η οποία προεραιτικά μπορεί να αποθηκευτεί σε αρχείο με το όρισμα `-ff=<filename>`.

Η σειριακή υλοποίηση έχει την εξής επίδοση:

#image("res/img/plot1_serial.png", width: 100%, height: 20%) 

Όπως αναμένουμε, επειδή ο αλγόριθμος χρησιμοποιεί έναν βρόχο για να υπολογίσει το $pi$, η επίδοσή του είναι γραμμική ($O(n)$) (στο διάγραμμα ο αριθμός των ρίψεων είναι σε λογαριθμική κλίμακα). 

Τώρα, ας δούμε τις παράλληλες υλοποιήσεις. Για να τις παραλληλοποιήσουμε, απλά χωρίσαμε τις ρίψεις ανά νήμα, με το κάθε νήμα να υπολογίζει το πλήθος $n/j$ ρίψεων, όπου $j$ είναι το πλήθος των νημάτων. Στο τέλος, τα νήματα συγχρονίζονται για να υπολογίσουν το τελικό αποτέλεσμα. Οι υλοποιήσεις έχουν τις εξής επιδόσεις:

#image("res/img/plot1_pthreads.png", width: 100%, height: 25%) 
#image("res/img/plot1_omp.png", width: 100%, height: 25%)

Από άποψη των επιδόσεων μεταξύ τους, δεν παρατηρείται μεγάλη διαφορά (κάτι που ίσως να ερμηνευθεί και ως θετικό για την OpenMP, αφού παρά το γεγονός ότι είναι πολύ υψηλότερου επιπέδου από την pthreads, οι επιδόσεις της είναι συγκρίσιμες). 

Ωστόσο, αυτό που παρατηρούμε και στις δύο υλοποιήσεις είναι το εξής: όταν ανεβούμε πάνω από τα 4 νήματα, οι επιδόσεις _δεν_ βελτιώνονται· αντ`αυτού, μένουν (περίπου) στάσιμες. Αυτό εύκολα ερμηνεύεται από το γεγονός ότι το σύστημα το οποίο χρησιμοποιήθηκε για την εκτέλεση της άσκησης έχει μόνον 4 φυσικούς πυρήνες. Ως εκ τούτου, (λόγω της αρχής του περιστερώνα) τουλάχιστον 2 νήματα θα πρέπει να εκτελεστούν σε έναν πυρήνα, το οποίο σημαίνει ότι θα έχουμε σειριοποίηση της εκτέλεσης για νήματα περισσότερα από 4.

Να σημειωθεί ότι στην παράλληλη υλοποίηση χρησιμοποιήθηκε συγχρονισμός, αλλά μόνον για την ενημέρωση του τελικού μετρητή των ρίψεων (δηλαδή όταν ένα νήμα είχε ήδη πραγματοποιήσει όλες τις ρίψεις ανατεθιμένες σε αυτό). Αυτό βοήθησε στην μείωση πιθανών καθυστερήσεων λόγω αναμονής για ενημέρωση μιας κοινόχρηστης μεταβλητής. 