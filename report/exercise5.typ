Στην άσκηση αυτήν ασχολούμαστε με την βελτιστοποίηση ενός αλγορίθμου πολλαπλασιασμού πίνακα με άνυσμα για την περίπτωση που ο πίνακας είναι τριγωνικός. Για να το επιτύχουμε αυτό, αξιοποιήσαμε τον όρο `schedule()` της OpenMP, ο οποίος μας επιτρέπει να αναδιανείμουμε νέο έργο στα νήματα, όταν αυτά τελειώσουν το τρέχον έργο τους. Αυτό είναι χρήσιμο, δεδομένου ότι κάθε νήμα εκτελεί τον εξής αλγόριθμο:

```c
for (uint32_t j = i; j < n; j++) 
{
  sum += A[i][j] * x[j];
}
```
όπου $A$ είναι ο πίνακας και $x$ το διάνυσμα, $i$ η ταυτότητα του νήματος και η τρέχουσα γραμμή που διαχειρίζεται και $n$ το πλήθος των γραμμών του πίνακα (που είναι ίσος με το πλήθος των στηλών, αφού οι τριγωνικοί πίνακες είναι τετράγωνοι). Για νήματα τα οποία αναλαμβάνουν τα «κάτω» μέρη του πίνακα, βλέπουμε η δουλειά τους θα τελειώσει σχετικά γρήγορα. Ως εκ τούτου, θα αποτελούσε μεγάλη σπατάλη να μην τα αξιοποιούσαμε για να αναλάβουν και κάποιους άλλους υπολογισμούς.

Ο πηγαίος κώδικας της άσκησης βρίσκεται στο αρχείο `src/better_mul.c`.

Η άσκηση δέχεται ως ορίσματα το πλήθος των νημάτων που θα χρησιμοποιηθούν (`-fj=<number>`), το μέγεθος του πίνακα (`-fm=<number>x<number>`) και αν αυτός είναι τριγωνικός (`-fu`) και, τέλος, αν θα χρησιμοποιηθεί η πρωτότυπη (`-fO0`) ή η βελτιστοποιημένη υλοποίηση (`-fO1`). Η έξοδος περιέχει τον χρόνο εκτέλεσης του αλγορίθμου, όπως και την υλοποίηση που χρησιμοποιήθηκε αλλά και το μέγεθος του πίνακα, η οποία προεραιτικά μπορεί να αποθηκευτεί σε αρχείο με το όρισμα `-ff=<filename>`.

Λόγω περιορισμών μνήμης, η άσκηση δεν μπορεί να εκτελεστεί με πίνακες μεταλύτερους από $10000 times 10000$ (ήδη ένας πίνακας $100000 times 100000$ δεκαδικών διπλής ακρίβειας απαιτεί _$80 text("GB")$_ μνήμης). Παράλληλα, για πίνακες μικρότερους από $10000 times 10000$, η βελτιστοποίηση δεν έχει νόημα, καθώς ο χρόνος εκτέλεσης είναι πολύ μικρός. Έτσι, ασχοληθήκαμε μόνο με πίνακες μεγέθους $10000 times 10000$, για διαφορετικό αριθμό νημάτων.

Πράγματι όμως, η σκέψη μας ως προς την χρήση του `schedule()` αποδείχθηκε σωστή, καθώς η βελτιστοποιημένη υλοποίηση είναι ταχύτερη από την πρωτότυπη. Ας δούμε τα αποτελέσματα: