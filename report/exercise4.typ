Στην άσκηση αυτήν υλοποιούμε φράγματα (barriers) με τη χρήση της αναμονής σε εγρήγορση (busy waiting) και με την χρήση μεταβλητών συνθήκης (condition variables) και τις συγκρίνουμε με τα εγγενή φράγματα του pthreads. Για την σύγκριση, κάθε νήμα τρέχει έναν ορισμένο αριθμό επαναλήψεων, όπου αναμένει το φράγμα.

Ο πηγαίος κώδικας της άσκησης βρίσκεται στο αρχείο `src/barriers.c`.

Η άσκηση δέχεται ως ορίσματα το πλήθος των επαναλήψεων (`-fn=<number>`), ποια υλοποίηση θα εκτελεστεί (`-fb` για την χρήση busy waiting, `-fc` για την χρήση condition variables και `-fp` για την χρήση του εγγενούς φράγματος του pthreads) και το πλήθος των νημάτων που θα χρησιμοποιηθούν (`-fj=<number>`). Η έξοδος είναι ο χρόνος εκτέλεσης του αλγορίθμου, όπως και η υλοποίηση που χρησιμοποιήθηκε αλλά και το πλήθος των επαναλήψεων, η οποία προεραιτικά μπορεί να αποθηκευτεί σε αρχείο με το όρισμα `-ff=<filename>`.

Λαμβάνουμε τα εξής αποτελέσματα:

#image("res/img/plot4_pthreads.png", width: 100%, height: 20%)
#image("res/img/plot4_condvar.png", width: 100%, height: 20%)
#image("res/img/plot4_busywait.png", width: 100%, height: 20%)

Μία κοινή τάση και στις τρεις υλοποιήσεις είναι η εξής:
- Όσα περισσότερα νήματα χρησιμοποιούμε, τόσο πιο αργά εκτελούνται οι υλοποιήσεις. Αυτό είναι αναμενόμενο, καθώς το φράγμα απαιτεί από όλα τα νήματα να περιμένουν το ένα το άλλο, οπότε όσο περισσότερα νήματα έχουμε, τόσο περισσότερο χρόνο θα χρειαστούν για να περιμένουν. Προφανώς, όταν έχουμε περισσότερα νήματα από φυσικούς πυρήνες, ο χρόνος αναμονής αυξάνεται και στις τρεις περιπτώσεις, αφού το σύστημα δεν μπορεί να εκτελέσει τα νήματα ταυτόχρονα.
- Όσες περισσότερες επαναλήψεις έχουμε, τόσο πιο αργά εκτελούνται οι υλοποιήσεις, το οποίο είναι επίσης αναμενόμενο, γιατί η αναμονή για το φράγμα είναι μία χρονοβόρα διαδικασία.

Το τρίτο που παρατηρούμε είναι ότι η ταχύτερη υλοποίηση είναι αυτή που χρησιμοποιεί αναμονή σε εγρήγορση ενώ η αργότερη αυτή που χρησιμοποιεί μεταβλητές συνθήκης.