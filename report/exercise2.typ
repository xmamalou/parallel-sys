Σε αυτήν την άσκηση, βάζουμε νήματα να ανανεώσουν μία κοινόχρηστη μεταβλητή (η οποία αρχικοποιείται στο $0$), για έναν καθορισμένο αριθμό επαναλήψεων. Αναμένουμε ότι στο τέλος της εκτέλεσης, η μεταβλητή αυτή θα έχει την τιμή $j times n$, όπου $j$ είναι το πλήθος των νημάτων και $n$ το πλήθος των επαναλήψεων. Για να το επιτύχουμε αυτό, χρησιμοποιούμε είτε κλειδώματα (mutexes) είτε ατομικές εντολές (atomics) και για να επιβεβαιώσουμε την λειτουργικότητα του συγχρονισμού, τοποθετούμε μία εντολή `assert` στο τέλος του προγράμματος, η οποία ελέγχει αυτήν την συνθήκη.

Ο πηγαίος κώδικας της άσκησης βρίσκεται στο αρχείο `src/shared_var.c`.

Η άσκηση δέχεται ως ορίσματα το πλήθος των επαναλήψεων (`-fn=<number>`), ποια υλοποίηση θα εκτελεστεί (`-fl` για την χρήση mutexes και `-fa` για την χρήση ατομικών εντολών) και το πλήθος των νημάτων που θα χρησιμοποιηθούν (`-fj=<number>`). Η έξοδος είναι ο χρόνος εκτέλεσης του αλγορίθμου, όπως και η υλοποίηση που χρησιμοποιήθηκε αλλά και το πλήθος των επαναλήψεων, η οποία προεραιτικά μπορεί να αποθηκευτεί σε αρχείο με το όρισμα `-ff=<filename>`.

Ας συγκρίνουμε τις επιδόσεις των δύο υλοποιήσεων:

#image("res/img/plot2_locks.png", width: 100%, height: 20%)
#image("res/img/plot2_atomic.png", width: 100%, height: 20%)

Δύο είναι οι παρατηρήσεις μας: 
+ Η υλοποίηση με atomics είναι κατά πολύ αργότερη από την υλοποίηση με mutexes.
+ Η υλποίηση με mutexes ακολουθεί τυχαία συμπεριφορά, αλλά εν γένει δεν αποκλίνει πολύ όσο μεγαλώνουν οι επαναλήψεις. Η υλοποίηση με atomics, έχει ντετερμινιστική συμπεριφορά και εκτοξεύεται ο χρόνος εκτέλεσης όσο μεγαλώνουν οι επαναλήψεις.

Ο λόγος που οι ατομικές εντολές εδώ βγήκαν βραδύτερες των mutexes είναι, μάλλον, λόγω του γεγονότος ότι έχουμε πολύ μεγάλο ανταγωνισμό για την κοινόχρηστη μεταβλητή, ειδικά όσο αυξάνεται ο αριθμός των νημάτων (περισσότερα νήματα θέλουν να ενημερώσουν πολλές φορές την ίδια μεταβλητή). Γενικά, τα atomics χρησιμεύουν σε καταστάσεις όπου ο ανταγωνισμός είναι σχετικά μικρός, αφού αυτά πρακτικά είναι ένα είδος busy waiting.

Όσον αφορά την «τυχαιότητα» της υλοποίησης με mutexes, αυτό εκλαμβάνεται περισσότερο ως «θόρυβος» στις μετρήσεις (καθώς ο κάθε πυρήνας δεν εκτελεί μόνον το δικό μας εκτελέσιμο), δεδομένου ότι η απόκλιση δεν είναι ιδιαιτέρως μεγάλη.